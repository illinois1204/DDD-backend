# О сути
#### Архитектура приложения построена на следующей предметной области (выдумана мной, просто чтобы отразить какую-нибудь действительность):

#### Имеется некая ферма (территория), она делиться на сектора, на каждом секторе может быть n-ое кол-во сенсоров. Каждый сенсор с определенной частотой отправляет данные о показателях почвы и все это записывается в БД.

#### Таким образом выделяется 3 сущности: sector, sensor, sensor-data.
```
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                  +                      +                     +
+                  +                      +              ●      +
+     ●     ●      +       ●              +                     +
+                  +                      +                     +
+   ●              +              ●       +                     +
+           ●      +                      +     ●               +
+                  +                      +                     +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                  +                      +                     +
+                  +                      +                     +
+                  +                      +          ●          +
+                  +          ●           +                     +
+                  +                      +                     +
+      ●           +                      +    ●             ●  +
+                  +                   ●  +                     +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+                  +                      +                     +
+       ●          +               ●      +    ●                +
+                  +                      +               ●     +
+        ●         +                      +                     +
+                  +                      +                     +
+            ●     +    ●                 +    ●          ●     +
+                  +                      +                     +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
```

# О приложении
Приложение состоит из 4 основных разделов:
```
●
|__app (транспортный слой со своими правилами обработки и валидации:
|       http, grpc, pub-sub, brokers)
|
|__cmd (раннеры запуска)
|
|__external (некомпилируемые ресурсы swagger, templates, proto)
|
|__internal ●
            |
            |__common (интерфейсы, хендлеры, типы, энумы)
            |
            |__db (драйверы подключения, миграции)
            |
            |__domain (описание сущностей и работа с репозиториями)
            |
            |__services (различные инструменты s3, jwt, mailer)

```
## Команды для запуска и работы с проектом

#### создать миграцию:
```sh
npx knex migrate:make -x ts --migrations-directory ./internal/db/sql/migrations _name_
```
или
```sh
npm run migrate:sql:make -- _name_
```

#### создать заполнение (seeder):
Исходные файлы выполняются в алфавитном порядке. В отличие от миграций, пронумерованных последовательностью создания.
```sh
npx knex seed:make -x ts --cwd ./internal/db/sql _name_
```
или
```sh
npm run seed:sql:make -- _name_
```

#### скрипты управления:
```sh
"lint": линт всего проекта
"build": билд проекта
"start": запуск билда
"start:dry": запуск билда на локальной машине (для теста)
"local": запуск при локальной разработке
"migrate:sql:make": создать миграцию (с передачей параметра)
"migrate:sql:up": запуск миграции
"migrate:sql:up:local": запуск миграции на локальной машине
"seed:sql:make": создать заполнение (с передачей параметра)
"seed:sql:up": запуск заполнения
"seed:sql:up:local": запуск заполнения на локальной машине
```

# Прочее
#### Для использования `Redis stream` (в качестве брокера) необходимо сперва создать стрим и группу и зафиксировать имя потребителя в окружении приложения. В случае скейлинга имена потребителей должны быть разными на каждой реплике!

#### В качестве альтернативы  `Redis stream` можно использовать `Redis list`. Настраиваются проще и также разветвляются на несколько реплик. Основное отличие - отсутствует подтверждение успешной обработки (ack), если необходимо по бизнес логике, но есть возможность перемещения в параллельный лист во время обработки, чтобы не потерять данные.
